#!/usr/bin/env python3

#This script adds a function that creates a .bin file with a specified number of random bits.
#The random numbers can come from either the CPU's CSTRNG (Very random, fast) or the NIST Randomness Beacon (True random, can be slow)

#NOTES ON NIST STUFF:
# 1. To reduce the number of requests made from NIST's servers, all data fetched from the randomness beacon is stored in a permanant file, beaconMaster.bin. 
# 2. The last record fetched from the NIST randomness beacon is stored in a perminant file, lastBeaconTimestamp.txt.
# 3. All files used and generated by this script lie in the same directory as this script.
# 4. If more than 25 requests are made from the NIST randomness beacon, expect this program to be SLOW.
#    This is because this program waits 1 sec between requests after making 25 requests, thereby reducing load on NIST's servers to levels below the likely SWATtable threashold.
#    I'll leave DoS-ing goverment agencies to the AI scrapers.

#Import the needed libraries
import os
import sys
import time
from nistbeacon import NistBeacon #pip install nistbeacon
#Documentation: https://nistbeacon.readthedocs.io/en/latest/usage.html






#get the directory of THIS script
workingDir = os.path.dirname(__file__)
workingDir = workingDir.replace("\\","/") #change all the double back slashes to single fwd slashes (fwd slashes work nicer) 


#Fetch a record from the NIST randomness beacon, append the result to beaconMaster.bin, and update lastBeaconTimestamp.txt.
def nistFetchNext():
    #Find and open lastBeaconTimestamp.txt and get the current timestamp
    lastTimestamp = -1
    try:
        with open(workingDir+"/lastBeaconTimestamp.txt",'r') as timestamp:
            try:
                lastTimestamp = int(timestamp.read())
            except ValueError:
                #There'a some bullshit in the timestamp text file. As such, we have no clue where we are and have to start from fresh.
                pass #Leave lastTimestamp at -1 to signal an error.
    except FileNotFoundError:
        #The timestamp text file doesn't exist. As such, we have no clue where we are and have to start from fresh.
         pass #Leave lastTimestamp at -1 to signal an error.
    
    if(-1 == lastTimestamp):
        #There was an error with reading the last timestamp. We have to start from fresh.

        #Delete both files, then re-create the beaconMaster as a blank file
        try:
            os.remove(workingDir+"/lastBeaconTimestamp.txt")
        except FileNotFoundError:
            #the lastBeaconTimestamp doesn't exist.
            pass
        try:
            os.remove(workingDir+"/beaconMaster.bin")
        except FileNotFoundError:
            #the beaconMaster doesn't exist.
            pass
        with open(workingDir+"/beaconMaster.bin", 'w') as file: 
            pass #do nothing
        
        #Set the timestamp to 0 so we get the first reading
        lastTimestamp = 0
    
    #fetch the next random 512 bits from the beacon
    # https://beacon.nist.gov/rest/record/next/<timestamp>
    fetched_record = NistBeacon.get_next(lastTimestamp)
    #Append the data to beaconMaster.bin
    with open(workingDir+"/beaconMaster.bin", 'ab') as file: 
        file.write(bytes.fromhex(fetched_record.output_value))#Append the data
    
    #Update lastBeaconTimestamp.txt
    with open(workingDir+"/lastBeaconTimestamp.txt", 'w') as file: 
        file.write(str(fetched_record.timestamp))#Append the data


#Ensure the beaconMaster.bin file is at least minimum_size bytes long.
def nistBeaconMastAtLeast(minimum_size: int):
    #Check if the file beaconMaster.bin exists. If not, call nistFetchNext() to create it and pull the first data 
    if(False == os.path.exists(workingDir+"/beaconMaster.bin")):
        nistFetchNext() #Re-setup the root stuff
    
    #Check if beaconMaster.bin isn't large enough
    
    if(os.path.getsize(workingDir+"/beaconMaster.bin") < minimum_size):
        #Not large enough
        i = 0 #keep track of how many times we've pulled data so we know when to slow down
        while(os.path.getsize(workingDir+"/beaconMaster.bin") < minimum_size):
            if(25 <= i):
                print("Waiting before requesting more data (already requested "+str(i*64)+" bytes)...")
                time.sleep(1) #If we've already submitted more than 25 requests, wait a second so we're not accidentally DoS-ing NIST
            nistFetchNext() #Get another 64 bytes of sweet randomness
            i += 1 #increment the iteration counter so we can avoid accidentally DoS-ing the US Government
        
    #Now we're large enough.


#Create a file with bytes_to_get bytes of random data and return that file's file path
def getRandNist(bytes_to_get: int):
    nistBeaconMastAtLeast(bytes_to_get) #Ensure that there's enough data in beaconMaster.bin

    
    outFileDir = workingDir+"/rand.bin"
    with open(workingDir+"/beaconMaster.bin",'rb') as beaconMaster:

        randomBytes = beaconMaster.read(bytes_to_get) #read bytes_to_get bytes from beaconMaster.bin
        
        with open(outFileDir,'wb') as outFile:
            outFile.write(randomBytes) #write the random data to the output file
    
    return outFileDir

#Create a file with bytes_to_get bytes of random data and return that file's file path
def getRandHexNist(bytes_to_get: int):
    nistBeaconMastAtLeast(bytes_to_get) #Ensure that there's enough data in beaconMaster.bin    
    outFileDir = workingDir+"/rand.hex"
    with open(workingDir+"/beaconMaster.bin",'rb') as beaconMaster:

        randomBytes = beaconMaster.read(bytes_to_get) #read bytes_to_get bytes from beaconMaster.bin
        
        with open(outFileDir,'w') as outFile:
            outFile.write(randomBytes.hex()) #write the random data to the output file as hex
    
    return outFileDir


#Get bytes_to_get bytes of pseudo-random data from the OS's CSTRNG and return it as a bytes like object
def getRand(bytes_to_get: int):
    csprngBytes = os.urandom(bytes_to_get)
    return csprngBytes

#Create a file with bytes_to_get bytes of pseudo-random data from the OS's CSPRNG and return that file's file path
def getRandFile(bytes_to_get: int):
    csprngBytes = os.urandom(bytes_to_get)
    outFileDir = workingDir+"/rand.bin"
    with open(outFileDir,'wb') as outFile:
         outFile.write(csprngBytes) #write the pseudo-random data to the output file
    return outFileDir

#Create a file with bytes_to_get bytes of pseudo-random data from the OS's CSPRNG and return that file's file path
def getRandFileHex(bytes_to_get: int):
    csprngBytes = os.urandom(bytes_to_get)
    outFileDir = workingDir+"/rand.hex"
    with open(outFileDir,'w') as outFile:
         outFile.write(csprngBytes.hex()) #write the pseudo-random data to the output file
    return outFileDir


if( __file__ == "__main__"): #This doesn't work for some reason on my new computer, it did on the old one.
    #print(getRandFileHex(10*1024*1024))
    print(getRandNist(1*1024*1024))
print(getRandNist(4*1024*1024))